---
#    self_contained: yes
output:
  github_document:
    html_preview: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 13,
  fig.height = 9 
)

set.seed(42)
```

```{r}
library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)

library(slendr)
init_env(quiet = TRUE)

suppressPackageStartupMessages(source(here::here("utils.R")))
```

## Testing the admixture dating methodology on simulations

```{r}
anc <- population("ancestor", N = 10000, time = 1000000, remove = 649000)
afr <- population("AFR", parent = anc, N = 10000, time = 650000)
nea <- population("NEA", parent = anc, N = 2000, time = 650000)
eur <- population("EUR", parent = afr, N = 5000, time = 80000)

gen_time <- 27
t_admix <- round(55000 / gen_time) * gen_time

gf <- gene_flow(from = nea, to = eur, rate = 0.03, start = t_admix, end = t_admix - gen_time)

model <- compile_model(
  populations = list(anc, afr, nea, eur), gene_flow = gf,
  generation_time = gen_time
)

samples <- schedule_sampling(model, times = c(50, 40, 30, 20, 10, 0) * 1e3, list(eur, 10))

plot_model(model, proportions = TRUE, order = c("AFR", "EUR", "ancestor", "NEA"))
```

```{r, eval=!file.exists("data/sim_tracts.tsv")}
ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8, samples = samples, random_seed = 42)

tracts_df <- ts_tracts(ts, census = t_admix, quiet = TRUE) %>%
  dplyr::select(-node_id, -pop, -source_pop, -source_pop_id)

samples_df <- ts_samples(ts)

tracts_df <- inner_join(samples_df, tracts_df, by = "name")

write.table(tracts_df, file = "data/sim_tracts.tsv",
            sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
```

```{r, eval=file.exists("data/sim_tracts.tsv")}
tracts_df <- read_tsv("data/sim_tracts.tsv")
```

## Comparison of filtered and unfiltered tract distributions

```{r}
min_length <- 50e3

ggplot() +
  geom_density(data = tracts_df,
               aes(length, y = after_stat(count), color = factor(time), linetype = "unfiltered")) +
  geom_density(data = filter(tracts_df, length >= min_length),
               aes(length, y = after_stat(count), color = factor(time), linetype = "filtered"),
               color = "black") +
  guides(color = "none") +
  labs(linetype = "tracts") +
  scale_linetype_manual(values = c("unfiltered" = "solid", "filtered" = "dashed")) +
  facet_wrap(~ time, labeller = labeller(time = function(x) paste("sample age =", x, "kya"))) +
  coord_cartesian(xlim = c(0, 1e6))
```

## Estimating admixture time from tract lengths

```{r}
# sample_age <- 0
# min_length <- 50e3

max_length <- 1e6

pdf("dating_sims.pdf", width = 14, height = 8)

results <- list(time = c(), min_length = c(), lambda_lm = c(), lambda_mean = c())

for (min_length in c(0, 50e3, 100e3)) {

plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0, 1), ylim = c(0, 1))
text(0.5, 0.5, paste("Minimum tract length:", min_length, "bp"), cex = 3)
  
for (sample_age in unique(samples$time)) {
  
# cat("minimum length:", min_length, "\nsample_age:", sample_age, "\n")

r <- 1e-8

filtered_tracts <- tracts_df %>% filter(time == sample_age, length >= min_length, length <= max_length)

bin_data <- hist(filtered_tracts$length, plot = FALSE, breaks = 100)
density <- bin_data$density
length <- bin_data$mids[density > 0]
density <- density[density > 0]

# lm estimate of admixture time
#   -- based on log-transformed linear fit of density vs tract length
lm_res <- lm(log(density) ~ length)
lambda_lm <- -coef(lm_res)[["length"]]
if (lambda_lm < 0) lambda_lm <- NA

t_gens_lm <- lambda_lm / r
t_lm <- t_gens_lm * gen_time + sample_age

# MLE estimate of admixture time
#  -- based on computing average length as the expectation of the theoretical exponential distribution
L <- mean(filtered_tracts$length)
lambda_mean <- 1 / (L - min_length)

t_gens_mean <- 1 / (r * 1 / lambda_mean)
t_mean <- t_gens_mean * gen_time + sample_age

# nls estimate -- computing the rate of decay (lambda) by fitting an exponential curve directly
lambda_nls <- tryCatch(
  {
    nls_res <- nls(density ~ SSasymp(length, Asym, R0, lrc))
    # https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/SSasymp
    exp(unname(coef(nls_res)["lrc"]))
  },
  warning = function(w) NA,
  error = function(e) NA
)

t_gens_nls <- lambda_nls / r
t_nls <- t_gens_nls * gen_time + sample_age

# plotting
orig_par <- par(no.readonly = TRUE)

par(mfrow = c(1, 2))

title <- sprintf("sample age %d, tract length [%d bp, %d Mb]", sample_age, min_length, max_length / 1e6)

legends <-c(sprintf("lm fit of t = %.1f kya", round(t_lm / 1e3, 1)),
            sprintf("MLE fit of t = %.1f kya", round(t_mean / 1e3, 1)),
            sprintf("nls fit of t = %.1f kya", round(t_nls / 1e3, 1)))

# plot the results on the original exponential scale (although we fit truncated exponential,
# the rate corresponds to the shape of the original unfiltered exponential function, so we
# compute dexp() on the original unfiltered x-axis scale for plotting purposes)
x_values <- seq(0, max_length, by = 5000)
y_lm <- dexp(x_values, rate = lambda_lm)
y_mean <- dexp(x_values, rate = lambda_mean)
y_nls <- dexp(x_values, rate = lambda_nls)

ylim <- c(min(c(density, y_lm, y_mean, y_nls), na.rm = TRUE),
          3e-5) #max(c(density, y_lm, y_mean, y_nls), na.rm = TRUE))
plot(length, density, xlim = c(0, max_length), main = title, ylim = ylim)
# we shift 
lines(x_values + min_length, y_lm, col = "purple", lty = 2, lwd = 2)
lines(x_values + min_length, y_mean, col = "blue", lty = 2, lwd = 2)
lines(x_values + min_length, y_nls, col = "green", lty = 2, lwd = 2)

legend("topright", fill = c("purple", "blue", "green"), legend = legends)

# plot the results on the log-transformed scale
plot(length, log(density), xlim = c(0, max_length), main = title, ylim = c(-15, -11))
abline(lm_res, col = "purple", lty = 2, lwd = 2)
abline(a = log(lambda_mean) + lambda_mean * min_length, b = -lambda_mean, col = "blue", lty = 2, lwd = 2)
if (!is.na(lambda_nls))
  abline(a = log(lambda_nls) + lambda_mean * min_length, b = -lambda_nls, col = "green", lty = 2, lwd = 2)

legend("topright", fill = c("purple", "blue", "green"), legend = legends)

par(orig_par)

results[["time"]] <- c(results[["time"]], sample_age)
results[["min_length"]] <- c(results[["min_length"]], min_length)
results[["lambda_lm"]] <- c(results[["lambda_lm"]], lambda_lm)
results[["lambda_mean"]] <- c(results[["lambda_mean"]], lambda_mean)
results[["lambda_nls"]] <- c(results[["lambda_nls"]], lambda_nls)

}
}

dev.off()

results_df <- as_tibble(results)
```

## Estimating admixture time from tract lengths v2

```{r}
pdf("dating_sims_v2.pdf", width = 12, height = 10)

max_length <- Inf

for (min_length in c(0, 25e3, 50e3, 100e3, 250e3)) {
tracts_filt_df <- tracts_df %>% filter(length >= min_length, length <= max_length)

p_tracts <-
  ggplot() +
  geom_histogram(data = tracts_filt_df, aes(x = length, y = after_stat(density), fill = as.factor(time)),
                 binwidth = 10000, alpha = 0.75) +
  labs(
    x = "tract length [bp]", y = "density", fill = "age of sample",
    title = "Tract length distribution as a function of admixed sample's age",
    subtitle = paste0(
      "(assuming single-pulse admixture at ~ 55 kya, tract length [", min_length, " bp, ", max_length / 1e6," Mb])"
    )
  ) +
  scale_x_continuous(labels = scales::comma) +
  expand_limits(y = 0) +
  coord_cartesian(ylim = c(0, 2e-5)) +
  theme_minimal() +
  theme(legend.position = "none", text = element_text(size = 15)) +
  facet_wrap(~ time, labeller = labeller(time = function(x) paste("sample age =", x, "kya")))

# p_tracts

r <- 1e-8

exp_df <- group_by(tracts_filt_df, time) %>%
  summarise(L = mean(length)) %>%
  mutate(
    lambda = 1 / (L - min_length),
    t_gen = 1 / (r / lambda),
    t_before = t_gen * gen_time,
    t_admix = t_before + time
  )

# exp_df

exp_decay <- function(lambda, max_length) {
  data.frame(length = seq(0, max_length, by = 100000)) %>%
    mutate(density = dexp(length, rate = lambda))
}

predictions_df <-
  exp_df %>%
  rowwise() %>%
  mutate(exp_data = list(exp_decay(lambda, max(tracts_filt_df$length)))) %>%
  unnest(cols = c(exp_data))

p_fit <- p_tracts +
  geom_line(data = predictions_df, aes(x = length + min_length, y = density),
            linetype = "dashed", linewidth = 0.75, color = "black") +
  geom_text(data = exp_df,
            aes(x = Inf, y = Inf, label = paste("estimated admixture at", round(t_admix / 1e3, 1), "kya"),
                color = as.factor(time)),
            hjust = 1.2, vjust = 8, size = 4)

print(p_fit)
}

dev.off()
```

## Admixture dating using empirical data

```{r}
metadata <- read_metadata()

metadata$age_group <- cut(metadata$ageAverage, breaks = c(Inf, 15e3, 10e3, 5e3,  0))
group_levels <- levels(metadata$age_group)

metadata <- metadata %>%
  mutate(
    age_group = as.character(age_group),
    age_group = ifelse(is.na(age_group), "present-day", age_group),
    age_group = factor(age_group, levels = c("present-day", group_levels))
  )
```

```{r}
ggplot(metadata) +
  geom_boxplot(aes(ageAverage, color = age_group))
```

```{r}
tracts_df <- rbind(read_tracts("Modern", metadata), read_tracts("Ancient", metadata))
tracts_df <- select(metadata, sampleId, ageAverage, age_group, coverage) %>%
  inner_join(tracts_df, by = c("sampleId" = "ID"))

tracts_df %>%
  group_by(age_group) %>%
  summarise(mean(ageAverage))
```

```{r}
ggplot(tracts_df) +
  geom_density(aes(length, color = age_group)) +
  coord_cartesian(xlim = c(0, 1e6))
```

```{r}
# sample_age <- "present-day"
# min_length <- 50e3

pdf("dating_empirical.pdf", width = 14, height = 8)

results <- list(time = c(), min_length = c(), lambda_lm = c(), lambda_mean = c())

max_length <- 1e6
for (min_length in c(50e3)) {
for (sample_age in levels(metadata$age_group)) {
  
cat("minimum length:", min_length, "\nsample_age:", sample_age, "\n")

r <- 1e-8

filtered_tracts <- tracts_df %>% filter(age_group == sample_age, length >= min_length, length <= max_length)

bin_data <- hist(filtered_tracts$length, plot = FALSE, breaks = 100)
density <- bin_data$density
length <- bin_data$mids[density > 0]
density <- density[density > 0]

# lm estimate
lm_res <- lm(log(density) ~ length, weights = 1 / length)
lambda_lm <- -coef(lm_res)[["length"]]
if (lambda_lm < 0) lambda_lm <- NA

t_gens_lm <- lambda_lm / r
t_lm <- t_gens_lm * gen_time + mean(filtered_tracts$ageAverage)

# MLE estimate
L <- mean(filtered_tracts$length)
lambda_mean <- 1 / (L - min_length)

t_gens_mean <- 1 / (r * 1 / lambda_mean)
t_mean <- t_gens_mean * gen_time + mean(filtered_tracts$ageAverage)

# plotting
orig_par <- par(no.readonly = TRUE)

par(mfrow = c(1, 2))

title <- sprintf("sample age %s, tract length [%d bp, %d Mb]", sample_age, min_length, max_length / 1e6)

legends <-c(sprintf("lm fit of t = %.1f kya", round(t_lm / 1e3, 1)),
            sprintf("MLE fit of t = %.1f kya", round(t_mean / 1e3, 1)))

# plot the results on the original exponential scale
y_lm <- dexp(length, rate = lambda_lm)
y_mean <- dexp(length, rate = lambda_mean)

plot(length, density, xlim = c(0, max(length)), main = title, ylim = c(0, 2e-5))
lines(length, y_lm, col = "orange", lty = 2)
lines(length, y_mean, col = "blue", lty = 2)

legend("topright", fill = c("orange", "blue"), legend = legends)

# plot the results on the log-transformed scale
plot(length, log(density), xlim = c(0, max(length)), ylim = log(c(0.000000001, 2e-5)), main = title)
abline(lm_res, col = "orange", lty = 2)
slope <- -lambda_mean
intercept <- log(lambda_mean)
abline(a = intercept, b = slope, col = "blue", lty = 2)

legend("topright", fill = c("orange", "blue"), legend = legends)

par(orig_par)

results[["time"]] <- c(results[["time"]], sample_age)
results[["min_length"]] <- c(results[["min_length"]], min_length)
results[["lambda_lm"]] <- c(results[["lambda_lm"]], lambda_lm)
results[["lambda_mean"]] <- c(results[["lambda_mean"]], lambda_mean)

}
}

dev.off()

results_df <- as_tibble(results)
```

