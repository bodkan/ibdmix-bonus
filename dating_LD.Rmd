---
#    self_contained: yes
output:
  github_document:
  html_preview: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 13,
  fig.height = 9
)

set.seed(42)

unlink("dating_LD_files", recursive = TRUE)
unlink(list.files(".", "dating_LD.*.pdf"), recursive = TRUE)
```

```{r}
library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)
library(cowplot)

library(plyranges)
library(ggbio)
library(BSgenome.Hsapiens.UCSC.hg19)

suppressPackageStartupMessages(source(here::here("utils.R")))
```

Parameters from the simulation:

```{r}
gen_time <- 27
t_admix <- round(55000 / gen_time) * gen_time
```

```{r, eval=file.exists("data/sim_tracts.tsv")}
tracts_df <-
  read_tsv("data/sim_tracts.tsv") %>%
  group_by(name) %>%
  mutate(haplotype = dense_rank(node_id),
         chrom = paste0("chr1_", haplotype)) %>%
  ungroup()

tracts_df
```

<!-- ```{r} -->
<!-- metadata <- read_metadata() -->
<!-- tracts_df <- rbind(read_tracts("Modern"), read_tracts("Ancient")) -->

<!-- tracts_df <- select(metadata, name = sampleId, ageAverage, coverage) %>% -->
<!--   inner_join(tracts_df, by = c("name" = "ID")) %>% -->
<!--   dplyr::rename(left = start, right = end) -->

<!-- tracts_df <- tracts_df %>% filter(name == "Kostenki") %>% arrange(chrom, left, right) -->
<!-- tracts_df$chrom_id <- tracts_df$chrom -->
<!-- ``` -->

```{r}
tracts_gr <- tracts_df %>%
  makeGRangesFromDataFrame(
    start.field = "left",
    end.field = "right",
    keep.extra.columns = TRUE,
    ignore.strand = TRUE,
    starts.in.df.are.0based = TRUE
  )
```

<!-- ```{r} -->
<!-- seqlengths(tracts_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg19)[names(seqlengths(tracts_gr))] -->
<!-- genome(tracts_gr) <- "hg19" -->
<!-- ``` -->

```{r}
seqlengths(tracts_gr) <- rep(100e6, 2)
```

```{r}
tracts_gr
```

### Define positions of archaic ancestry informative sites

```{r}
generate_info_sites <- function(tracts_gr, interval) {
  sites_grl <- lapply(seqlevels(tracts_gr), function(chrom) {
    positions <- seq(from = 1, to = seqlengths(tracts_gr)[chrom], by = interval)

    gr <- GRanges(seqnames = chrom, ranges = IRanges(start = positions, end = positions))
    mcols(gr)$index <- seq_len(length(gr))

    gr
  }) %>% GRangesList()
  seqlevels(sites_grl) <- seqlevels(tracts_gr)
  seqlengths(sites_grl) <- seqlengths(tracts_gr)

  sites_grl
}
```

### Define pairs of sites at given distances

```{r}
# Generate list of indices of all pairs of loci at given distances
# (one element of the list for each distance bin)
collect_pairs <- function(sites_grl, distances, ncores = parallel::detectCores()) {

  chr_pairs <- lapply(seqlevels(sites_grl), function(chrom) {

    sites_gr <- sites_grl[seqlevels(sites_grl) == chrom, ] %>% unlist

    pairs <- parallel::mclapply(distances, function(distance) {

        pair1 <- c()
        pair2 <- c()

        # iterate through each site one by one...
        for (i in sites_gr$index) {
          index1 <- i
          # ... and find the index of the first site that is at a given distance
          index2 <- sites_gr[start(sites_gr) >= start(sites_gr[i]) + distance]$index[1]

          if (is.na(index2)) {
            if (seqlengths(sites_gr)[chrom] < start(sites_gr[i]) + distance  + distance / 10)
              break
            else
              next
          }

          # otherwise record the indices of the pair of sites and proceed with searching
          # for the next pair
          pair1 <- c(pair1, index1)
          pair2 <- c(pair2, index2)
        }

        list(pair1 = pair1, pair2 = pair2)

      }, mc.cores = ncores)

    pairs

  })

  names(chr_pairs) <- seqlevels(sites_grl)
  chr_pairs
}
```

```{r}
interval <- 10e3

sites_grl <- generate_info_sites(tracts_gr, interval = interval)
distances <- seq(interval, 1e6, by = interval)

# unlink("dating_LD_pairs_regular.rds")
if (file.exists("dating_LD_pairs_regular.rds")) {
  pairs <- readRDS("dating_LD_pairs.rds")
} else {
  tstart <- Sys.time()
  pairs <- collect_pairs(sites_grl, distances)
  tend <- Sys.time()

  print(tend - tstart)
  saveRDS(pairs, "dating_LD_pairs_regular.rds")
}
```


### Compute covariance in a given individual

```{r}
tracts_gr$sample_age %>% unique
tracts_gr$name %>% unique
```

```{r}
compute_covariances <- function(tracts_gr, sites_grl, pairs) {
  lapply(seqlevels(sites_grl), function(chrom) {

    sites_gr <- sites_grl[seqlevels(sites_grl) == chrom, ] %>% unlist

    parallel::mclapply(unique(tracts_gr$name), function(name) {
      
      ind_tracts_gr <- tracts_gr %>% filter(name == !!name, seqnames == chrom)
      ind_sites_gr <- sites_gr
      
      # mark sites falling within an introgressed tract
      tract_overlaps <- queryHits(findOverlaps(ind_sites_gr, ind_tracts_gr))
      mcols(ind_sites_gr)$neand <- FALSE
      mcols(ind_sites_gr[tract_overlaps])$neand <- TRUE
      mcols(ind_sites_gr)$neand <- as.integer(mcols(ind_sites_gr)$neand)
    
      covariances <- sapply(seq_along(distances), function(i) {
        sites1 <- ind_sites_gr[pairs[[chrom]][[i]]$pair1]$neand
        sites2 <- ind_sites_gr[pairs[[chrom]][[i]]$pair2]$neand
        cov(sites1, sites2)
      })

      tibble(
        chrom = chrom,
        name = name,
        sample_age = unique(ind_tracts_gr$sample_age),
        distance = distances,
        covariance = covariances
      )
    }, mc.cores = detectCores()) %>% do.call(rbind, .)
  }) %>% do.call(rbind, .)
}
```

```{r}
length_cutoff <- 50e3

cov_df <- compute_covariances(filter(tracts_gr, length > length_cutoff), sites_grl, pairs)
```

```{r}
# cov_df <- cov_ind_df %>%  group_by(sample_age, distance) %>% summarise(covariance = mean(covariance))
```

```{r}
cov_df %>%
ggplot() +
  geom_line(aes(distance, covariance, color = factor(sample_age), group = interaction(chrom, name))) +
  facet_grid(~ sample_age) +
  coord_cartesian(xlim = c(0, max(distances))) +
  theme(legend.position = "bottom")
```

```{r}
tracts_gr %>%
filter(length > length_cutoff) %>%
as_tibble %>%
ggplot() +
  geom_density(aes(length, color = factor(sample_age), group = name)) +
  facet_grid(. ~ sample_age) +
  coord_cartesian(xlim = c(0, max(distances)))
```


```{r}
chrom <- "chr1_2"
name <- "EUR_10"

sites_gr <- sites_grl[seqlevels(sites_grl) == chrom, ] %>% unlist
ind_tracts_gr <- tracts_gr %>% filter(name == !!name, seqnames == chrom)
ind_sites_gr <- sites_gr

# mark sites falling within an introgressed tract
tract_overlaps <- queryHits(findOverlaps(ind_sites_gr, ind_tracts_gr))
mcols(ind_sites_gr)$neand <- FALSE
mcols(ind_sites_gr[tract_overlaps])$neand <- TRUE
mcols(ind_sites_gr)$neand <- as.integer(mcols(ind_sites_gr)$neand)
    
ggplot() +
  geom_rect(data = as.data.frame(ind_tracts_gr), aes(xmin = start, xmax = end, ymin = 0.1, ymax = 1.5), fill = "blue") +
  geom_point(data = as.data.frame(filter(ind_sites_gr, neand == 1)), aes(x = start, y = 0.05), size = 0.1, color = "red") +
  geom_point(data = as.data.frame(ind_sites_gr), aes(x = start, y = 0), size = 0.1, alpha = 0.05) +
  scale_x_continuous(labels = scales::comma) +
  expand_limits(x = 0) +
  theme_minimal() +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank(), panel.grid = element_blank())
```



## Fitting exponential distribution to covariances

```{r}
sample_age <- 40000
name <- sample(filter(cov_df, sample_age == !!sample_age)$name, 1)
chrom <- sample(filter(cov_df, sample_age == !!sample_age)$chrom, 1)

gen_time <- 27
r <- 1e-8

data_df <- filter(cov_df, name == !!name, chrom == !!chrom) #sample_age == !!sample_age)

# nls_res <- nls(covariance ~ exp(-lambda * distance * r) + c, 
#                data = data_df,  start = list(A = 1, lambda = 1/50000, c = 0))

nls_res <- nls(covariance ~ SSasymp(distance, Asym, R0, lrc), data = data_df)

summary(nls_res)

plot(data_df$distance, data_df$covariance)
y_nls <- predict(nls_res, newdata = data_df[, c("sample_age", "distance")]) %>% as.vector
lines(data_df$distance, y_nls)

lambda_nls <- exp(coef(nls_res)["lrc"])
(t_gens_nls <- lambda_nls / r)
(t_nls <- t_gens_nls * gen_time + sample_age)
```

```{r}
fit_df <- expand_grid(chrom = seqlevels(tracts_gr), name = unique(tracts_gr$name)) %>%
  rowwise() %>%
  mutate(fit_data = list((
    function(chrom, name) {
      data_df <- filter(cov_df, name == !!name, chrom == !!chrom)
      nls_res <- nls(covariance ~ SSasymp(distance, Asym, R0, lrc), data = data_df)
    
      df <- tibble(
        distance = data_df$distance,
        covariance = predict(nls_res, newdata = data_df[, "distance"])
      )
    
      tibble(
        sample_age = sample_age,
        lambda = exp(coef(nls_res)["lrc"]),
        t_gens_before = lambda / r,
        t_admix = t_gens_before * gen_time + sample_age,
        fit = list(df)
      )
    })(chrom, name)
  )) %>%
    unnest(cols = c(fit_data))
```

```{r}
grid_df <- expand_grid(chrom = seqlevels(tracts_gr), name = unique(tracts_gr$name))

fit_df <- lapply(1:nrow(grid_df), function(i) {
  name <- grid_df[i, ]$name
  chrom <- grid_df[i, ]$chrom

  data_df <- filter(cov_df, name == !!name, chrom == !!chrom)
  nls_res <- nls(covariance ~ SSasymp(distance, Asym, R0, lrc), data = data_df)

  df <- tibble(
    distance = data_df$distance,
    covariance = predict(nls_res, newdata = data_df[, "distance"])
  )

  tibble(
    name = name,
    chrom = chrom,
    sample_age = data_df$sample_age[1],
    lambda = exp(coef(nls_res)["lrc"]),
    t_gens_before = lambda / r,
    t_admix = t_gens_before * gen_time + sample_age,
    fit = list(df)
  )
}) %>%
  do.call(rbind, .) %>%
  unnest(fit)
```


```{r}
sample_age <- 40000
name <- sample(filter(cov_df, sample_age == !!sample_age)$name, 1)

ind_cov_df <- filter(cov_df, name == !!name)
ind_fit_df <- filter(fit_df, name == !!name)

ggplot() +
  geom_line(data = ind_cov_df, aes(distance, covariance)) +
  geom_line(data = ind_fit_df, aes(distance, covariance), color = "red", linetype = "dashed") +
  facet_wrap(~ chrom)
```

```{r}
fit_df %>%
ggplot(aes(sample_age, t_admix, group = sample_age)) +
  geom_boxplot() +
  geom_point() +
  geom_hline(yintercept = t_admix, linetype = "dashed") +
  coord_cartesian(ylim = c(0, 100e3))
```





### Exponential fitting across all individuals
```{r}
fit_df <- lapply(c(0, 10e3, 20e3, 30e3, 40e3, 50e3), function(sample_age) {
  data_df <- filter(cov_df, sample_age == !!sample_age)
  nls_res <- nls(covariance ~ SSasymp(distance, Asym, R0, lrc), data = data_df)

  df <- tibble(
    distance = data_df$distance,
    covariance = predict(nls_res, newdata = data_df[, "distance"])
  )

  tibble(
    sample_age = sample_age,
    lambda = exp(coef(nls_res)["lrc"]),
    t_gens_before = lambda / r,
    t_admix = t_gens_before * gen_time + sample_age,
    fit = list(df)
  )
}) %>% do.call(rbind, .)

fit_df
```


```{r}
p_fit <- ggplot() +
  geom_line(data = cov_df, aes(distance, covariance, color = factor(sample_age))) +
  geom_line(data = unnest(fit_df, fit), aes(distance, covariance, color = factor(sample_age)), linetype = "dashed")

p_fit

p_fit + facet_wrap(~ sample_age) +
  geom_line(data = unnest(fit_df, fit), aes(distance, covariance), linetype = "dashed")
```






