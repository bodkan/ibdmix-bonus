---
#    self_contained: yes
output:
  github_document:
  html_preview: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 13,
  fig.height = 9
)

set.seed(42)

unlink("dating_LD_files", recursive = TRUE)
unlink(list.files(".", "dating_LD.*.pdf"), recursive = TRUE)
```

```{r}
library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)
library(cowplot)

library(plyranges)
library(ggbio)
library(BSgenome.Hsapiens.UCSC.hg19)

suppressPackageStartupMessages(source(here::here("utils.R")))
```

```{r, eval=file.exists("data/sim_tracts.tsv")}
tracts_df <-
  read_tsv("data/sim_tracts.tsv") %>%
  group_by(name) %>%
  mutate(haplotype = dense_rank(node_id),
         chrom = paste0("chr1_", haplotype)) %>%
  ungroup()

tracts_df
```

<!-- ```{r} -->
<!-- metadata <- read_metadata() -->
<!-- tracts_df <- rbind(read_tracts("Modern"), read_tracts("Ancient")) -->

<!-- tracts_df <- select(metadata, name = sampleId, ageAverage, coverage) %>% -->
<!--   inner_join(tracts_df, by = c("name" = "ID")) %>% -->
<!--   dplyr::rename(left = start, right = end) -->

<!-- tracts_df <- tracts_df %>% filter(name == "Kostenki") %>% arrange(chrom, left, right) -->
<!-- tracts_df$chrom_id <- tracts_df$chrom -->
<!-- ``` -->

```{r}
tracts_gr <- tracts_df %>%
  makeGRangesFromDataFrame(
    start.field = "left",
    end.field = "right",
    keep.extra.columns = TRUE,
    ignore.strand = TRUE,
    starts.in.df.are.0based = TRUE
  )
```

<!-- ```{r} -->
<!-- seqlengths(tracts_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg19)[names(seqlengths(tracts_gr))] -->
<!-- genome(tracts_gr) <- "hg19" -->
<!-- ``` -->

```{r}
seqlengths(tracts_gr) <- rep(100e6, 2)
```

```{r}
tracts_gr
```

### Define positions of archaic ancestry informative sites

```{r}
generate_info_sites <- function(tracts_gr, interval) {
  sites_grl <- lapply(seqlevels(tracts_gr), function(chrom) {
    positions <- seq(from = 1, to = seqlengths(tracts_gr)[chrom], by = interval)

    gr <- GRanges(seqnames = chrom, ranges = IRanges(start = positions, end = positions))
    mcols(gr)$index <- seq_len(length(gr))

    gr
  }) %>% GRangesList()
  seqlevels(sites_grl) <- seqlevels(tracts_gr)
  seqlengths(sites_grl) <- seqlengths(tracts_gr)

  sites_grl
}
```

### Define pairs of sites at given distances

```{r}
# Generate list of indices of all pairs of loci at given distances
# (one element of the list for each distance bin)
collect_pairs <- function(sites_grl, distances, ncores = parallel::detectCores()) {

  chr_pairs <- lapply(seqlevels(sites_grl), function(chrom) {

    sites_gr <- sites_grl[seqlevels(sites_grl) == chrom, ] %>% unlist

    pairs <- parallel::mclapply(distances, function(distance) {

        pair1 <- c()
        pair2 <- c()

        # iterate through each site one by one...
        for (i in sites_gr$index) {
          index1 <- i
          # ... and find the index of the first site that is at a given distance
          index2 <- sites_gr[
            (start(sites_gr) >= start(sites_gr[i]) + distance - distance / 10) & 
            (start(sites_gr) <= start(sites_gr[i]) + distance  + distance / 10)
          ]$index[1]

          if (is.na(index2)) {
            if (seqlengths(sites_gr)[chrom] < start(sites_gr[i]) + distance  + distance / 10)
              break
            else
              next
          }

          # otherwise record the indices of the pair of sites and proceed with searching
          # for the next pair
          pair1 <- c(pair1, index1)
          pair2 <- c(pair2, index2)
        }

        list(pair1 = pair1, pair2 = pair2)

      }, mc.cores = ncores)

    pairs

  })

  names(chr_pairs) <- seqlevels(sites_grl)
  chr_pairs
}
```

```{r}
interval <- 10e3

sites_grl <- generate_info_sites(tracts_gr, interval = interval)
distances <- seq(interval, 1e6, by = interval)

unlink("dating_LD_pairs_regular.rds")
if (file.exists("dating_LD_pairs_regular.rds")) {
  pairs <- readRDS("dating_LD_pairs.rds")
} else {
  tstart <- Sys.time()
  pairs <- collect_pairs(sites_grl, distances)
  tend <- Sys.time()

  print(tend - tstart)
  saveRDS(pairs, "dating_LD_pairs_regular.rds")
}
```


### Compute covariance in a given individual

```{r}
tracts_gr$sample_age %>% unique
tracts_gr$name %>% unique
```

```{r}
library(parallel)

compute_covariances <- function(tracts_gr, sites_grl) {
  chr_pairs <- lapply(seqlevels(sites_grl), function(chrom) {

    sites_gr <- sites_grl[seqnames(sites_grl) == chrom, ][[1]]

    parallel::mclapply(unique(tracts_gr$chrom_id), function(chrom_id) {
      # name <- "EUR_60"
      # chrom_ids <- filter(tracts_gr, name == !!name)$chrom_id %>% unique
      # chrom_id <- "EUR_60_119"
      
      ind_tracts_gr <- tracts_gr %>% filter(chrom_id == !!chrom_id)
      ind_sites_gr <- sites_gr
      
      # mark sites falling within an introgressed tract
      tract_overlaps <- queryHits(findOverlaps(ind_sites_gr, ind_tracts_gr))
      mcols(ind_sites_gr)$neand <- FALSE
      mcols(ind_sites_gr[tract_overlaps])$neand <- TRUE
      mcols(ind_sites_gr)$neand <- as.integer(mcols(ind_sites_gr)$neand)
    
      covariances <- sapply(seq_along(distances), function(i) {
        sites1 <- ind_sites_gr[pairs[[i]]$pair1]$neand
        sites2 <- ind_sites_gr[pairs[[i]]$pair2]$neand
        cov(sites1, sites2)
      })

  tibble(
    chrom_id,
    sample_age = unique(ind_tracts_gr$sample_age),
    distance = distances,
    covariance = covariances
  )
}, mc.cores = detectCores()) %>%
  do.call(rbind, .)
```

```{r}
cov_df %>%
ggplot() +
  geom_line(aes(distance, covariance, color = factor(sample_age), group = chrom_id)) +
  facet_wrap(~ sample_age) +
  coord_cartesian(xlim = c(0, max(distances)))
```

```{r}
tracts_gr %>%
as_tibble %>%
ggplot() +
  geom_density(aes(length, color = factor(sample_age), group = chrom_id)) +
  facet_wrap(~ sample_age) +
  coord_cartesian(xlim = c(0, max(distances)))
```



```{r}
ggplot() +
  geom_rect(data = as.data.frame(ind_tracts_gr), aes(xmin = start, xmax = end, ymin = 0.1, ymax = 1.5), fill = "blue") +
  geom_point(data = filter(as.data.frame(ind_sites_gr), neand == 1), aes(x = start, y = 0.05), size = 0.1, color = "red") +
  geom_point(data = as.data.frame(ind_sites_gr), aes(x = start, y = 0), size = 0.1, alpha = 0.05) +
  scale_x_continuous(labels = scales::comma) +
  expand_limits(x = 0) +
  theme_bw() +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank())
```






